<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
<style type="text/css">
    html {
        background: #4c4b4b;
    }
</style>
<body>
    <script>
        const sphereRadius = 10;
        const N = 2;
	const power = 2;
	const pointRadius = 0.5;
        const FF = 0.5; //friction force
        const dT = 0.01;  

	var clock = new THREE.Clock();
        var temp = 0;
        
        var debug = 0;
        var points = [];
	var charge = [];
        var v = []; // velocity

        var emptyVector = new THREE.Vector3();

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);


        var renderer = new THREE.WebGLRenderer({
            alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var geometry = new THREE.SphereGeometry(sphereRadius, 50, 50);
        var wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true }); 
        var sphere = new THREE.Mesh(geometry, wireframeMaterial);
        scene.add(sphere);

        
        
        for (i = 0; i < N; i++) {
            var geometry = new THREE.SphereGeometry(pointRadius, 4, 4);
            var wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false, transparent: false }); 
            var pointG = new THREE.Mesh(geometry, wireframeMaterial);
            var point = new THREE.Vector3(random(-5.9,5.9),random(-5.9,5.9),random(-5.9,5.9));
            points.push(point);

            v.push(emptyVector); // add speed 0

	    charge.push((i % 2 == 0) ? -1 : 1); // add charge 
            pointG.isPoint__ = true;
            scene.add(pointG);
            pointG.position.copy(point);
        }

        controls = new THREE.TrackballControls(camera);
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 3.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = true;
        controls.staticMoving = false;
        controls.dynamicDampingFactor = 0.2;

        controls.addEventListener('change', () => {
            renderer.render(scene, camera);
        });

        camera.position.z = 30;

        function calc() {
            var a;
            for (i = 0; i < N; i++) {

                a = emptyVector;
                for (j = 0; j < N; j++) {

                    if (i != j) {
                        r = points[i].distanceTo(points[j]);

			
				
			var sumCharge = charge[i] * charge[j];
			var norm = (new THREE.Vector3(points[j].x - points[i].x,points[j].y - points[i].y, points[j].z - points[i].z)).normalize();
                        var f = norm.multiplyScalar(sumCharge / Math.pow(r, power));
			
			a.add(f);
			
                    }
                }
		
		var aNew = a.clone();
                v[i].add(aNew.multiplyScalar(dT));
		var vNew = v[i].clone();
		
                points[i].add(vNew.multiplyScalar(dT * FF));
		

            }

                
        }

	function printTwent(o) {
		if (debug < 20) {
			console.log(o);
			debug++;
		}
	}

        var render = () => {
            requestAnimationFrame(render);

            controls.update();
            
            var t = clock.getDelta();
            temp += t;
            if (temp > 0.05) {
                calc();
                flag = 0;
                for (i = 0; i < scene.children.length; i++) {
                    var object = scene.children[i];
                    if (object.isPoint__ != undefined) {
                        if (flag == 0) {
                            flag = 1;
                            u = i;
                        }
                        object.position.copy(points[i - u]);
                    }
                }
                temp = 0;
            }
            renderer.render(scene, camera);
        };

        render();
    </script>
</body>
